#!/bin/bash
# Push the next commit, modifying its date to the next day

set -eu

# On macOS, use gnubin
if [[ "$(uname)" == "Darwin" ]]; then
    export PATH="/opt/homebrew/opt/coreutils/libexec/gnubin:$PATH"
fi

# -j days to jump (next day interval)
next_day_interval=1
# -r generate random time in the day
random_enabled=false
# -n number of commits to push
commit_count=1
# -s spread commits over consecutive days (one per day)
spread_days=false
# -i for interractive mode, which waits for a confirmation
interactive=false

while getopts "irsj:n:" opt; do
    case $opt in
        i) interactive=true ;;
        r) random_enabled=true ;;
        s) spread_days=true ;;
        j)
            next_day_interval="$OPTARG"
            echo "Next day interval set to $next_day_interval."
            if ((next_day_interval < 1)); then
                echo "Error: Next day interval must be at least 1." >&2
                exit 1
            fi
            ;;
        n)
            commit_count="$OPTARG"
            if ((commit_count < 1)); then
                echo "Error: Commit count must be at least 1." >&2
                exit 1
            fi
            ;;
        \?|:) exit 1 ;;
    esac
done

TMP_BRANCH="tmp-delay"
branch_name=$(git rev-parse --abbrev-ref HEAD)

cleanup() {
    echo -n "Deleting temporary branch ${TMP_BRANCH}..."
    git branch -qD ${TMP_BRANCH}
    echo "done"
}

# Checks
if ! git diff --quiet || ! git diff --cached --quiet; then
    echo "Error: You have uncommitted changes. Please commit or stash them before running this script." >&2
    exit 1
fi

if git show-ref --verify --quiet refs/heads/${TMP_BRANCH}; then
    echo "Error: Temporary branch ${TMP_BRANCH} already exists. Please delete it before running this script." >&2
    exit 1
fi

if ! git show-ref --verify --quiet refs/remotes/origin/${branch_name}; then
    echo "Error: Branch ${branch_name} does not exist on origin." >&2
    exit 1
fi

commits=($(git rev-list origin/${branch_name}..${branch_name} --reverse | head -n ${commit_count}))
if (( ${#commits[@]} == 0 )); then
    echo "Error: No commits to push on ${branch_name}." >&2
    exit 1
fi
if (( ${#commits[@]} != commit_count )); then
    echo "Error: Requested ${commit_count} commits, but only ${#commits[@]} are available to push on ${branch_name}." >&2
    exit 1
fi

# Dates generation
latest_pushed_date=$(git show -s --format=%cI "origin/${branch_name}")
new_day=$(date -d "$latest_pushed_date + ${next_day_interval} day" +%Y-%m-%d)
time_format="%H:%M:%S%z"
format="+%Y-%m-%d $time_format"
new_dates=()

for ((i = 0; i < commit_count; i++)); do
    # In spread mode, each commit goes on a separate consecutive day
    if $spread_days; then
        day=$(date -d "$new_day + $i day" +%Y-%m-%d)
    else
        day=$new_day
    fi

    # Random time or preserve original commit time
    if $random_enabled; then
        time="$((RANDOM % 24)):$((RANDOM % 60)):$((RANDOM % 60))"
    else
        time=$(date -d "$(git show -s --format=%aI "${commits[$i]}")" +"$time_format")
    fi

    new_dates+=("$(date -d "$day $time" "$format")")
done

# Re organizing commit dates
IFS=$'\n' sorted_new_dates=($(printf '%s\n' "${new_dates[@]}" | sort))
unset IFS

# Transform to string for export
printf -v dates_str '%s|' "${sorted_new_dates[@]}"
dates_str="${dates_str%|}"

# Create tmp branch on the latest commit to push, then rebase to amend dates
last_idx=$((commit_count - 1))
latest_commit="${commits[$last_idx]}"
echo -n "Switching to ${TMP_BRANCH}..."
git switch -qc ${TMP_BRANCH} ${latest_commit}
echo "done"

# Needs an export for the git rebase --exec to access it
export dates_str
git rebase origin/${branch_name} --exec \
'n=$(cat .git/rebase-merge/msgnum); idx=$((n/2)); date=$(echo "$dates_str" | cut -d"|" -f$idx); GIT_COMMITTER_DATE="$date" git commit --amend --no-edit --date="$date"' >/dev/null

echo -n "Returning to ${branch_name}..."
git switch ${branch_name} -q
echo "done"

if $interactive; then
    read -r -p "Branch ${TMP_BRANCH} will be pushed to remote ${branch_name}. Continue? (y/n) " response
    if [[ "$response" != "y" && "$response" != "Y" ]]; then
        echo "Operation cancelled."
        cleanup
        exit 0
    fi
fi

echo -n "Rebasing ${branch_name} onto ${TMP_BRANCH}..."
git -c advice.skippedCherryPicks=false rebase ${TMP_BRANCH} -q
echo "done"

echo -n "Pushing to remote ${branch_name}..."
git push origin ${TMP_BRANCH}:${branch_name} -q
echo "done"

cleanup

echo "Pushed delayed commit to remote ${branch_name} successfully."
